--- src/game/MovementHandler.cpp
+++ src/game/MovementHandler.cpp
@@ -315,81 +343,444 @@ void WorldSession::HandleMovementOpcodes(WorldPacket& recv_data)
     {
         // transports size limited
         // (also received at zeppelin/lift leave by some reason with t_* as absolute in continent coordinates, can be safely skipped)
-        if (movementInfo.GetTransportPos()->GetPositionX() > 50 || movementInfo.GetTransportPos()->GetPositionY() > 50 || movementInfo.GetTransportPos()->GetPositionZ() > 50)
+        if (movementInfo.GetTransportPos()->GetPositionX() > 60 || movementInfo.GetTransportPos()->GetPositionY() > 60 || movementInfo.GetTransportPos()->GetPositionZ() > 60)
             return;
 
         if (!Oregon::IsValidMapCoord(movementInfo.GetPos()->GetPositionX() + movementInfo.GetTransportPos()->GetPositionX(), movementInfo.GetPos()->GetPositionY() + movementInfo.GetTransportPos()->GetPositionY(),
                                      movementInfo.GetPos()->GetPositionZ() + movementInfo.GetTransportPos()->GetPositionZ(), movementInfo.GetPos()->GetOrientation() + movementInfo.GetTransportPos()->GetOrientation()))
             return;
 
-        // if we boarded a transport, add us to it
-        if (plMover && !plMover->m_transport)
-        {
-            // elevators also cause the client to send MOVEMENTFLAG_ONTRANSPORT - just unmount if the guid can be found in the transport list
-            for (MapManager::TransportSet::iterator iter = MapManager::Instance().m_Transports.begin(); iter != MapManager::Instance().m_Transports.end(); ++iter)
-            {
-                if ((*iter)->GetGUID() == movementInfo.t_guid)
-                {
-                    // unmount before boarding
-                    plMover->RemoveSpellsCausingAura(SPELL_AURA_MOUNTED);
-
-                    plMover->m_transport = (*iter);
-                    (*iter)->AddPassenger(plMover);
-                    break;
+        if (plMover && plMover->m_anti_transportGUID == 0 && movementInfo.t_guid != 0)
+         {
+            // if we boarded a transport, add us to it
+            if (!plMover->m_transport)
+             {
+                float trans_rad = movementInfo.GetTransportPos()->GetPositionX()*movementInfo.GetTransportPos()->GetPositionX() + movementInfo.GetTransportPos()->GetPositionY()*movementInfo.GetTransportPos()->GetPositionY() + movementInfo.GetTransportPos()->GetPositionZ()*movementInfo.GetTransportPos()->GetPositionZ();
+                if (trans_rad > 3600.0f) // transport radius = 60 yards //cheater with on_transport_flag
+                 {
+                    return;
                 }
-            }
+                // elevators also cause the client to send MOVEFLAG_ONTRANSPORT - just unmount if the guid can be found in the transport list
+                for (MapManager::TransportSet::iterator iter = MapManager::Instance().m_Transports.begin(); iter != MapManager::Instance().m_Transports.end(); ++iter)
+                {
+                    if ((*iter)->GetGUID() == movementInfo.t_guid)
+                    {
+                        // unmount before boarding
+                        plMover->RemoveSpellsCausingAura(SPELL_AURA_MOUNTED);
+
+                        plMover->m_transport = (*iter);
+                        (*iter)->AddPassenger(plMover);
+                        break;
+                    }
+                 }
+             }
+
+            GameObject* obj = HashMapHolder<GameObject>::Find(movementInfo.t_guid);
+            if (obj)
+                plMover->m_anti_transportGUID = obj->GetDBTableGUIDLow();
+            else
+                plMover->m_anti_transportGUID = GUID_LOPART(movementInfo.t_guid);
+
+            if (World::GetMvAnticheatDebug())
+                sLog.outDetail("On Transport %d", plMover->m_anti_transportGUID ? plMover->m_anti_transportGUID : 0);
         }
     }
     else if (plMover && plMover->m_transport)               // if we were on a transport, leave
     {
-        plMover->m_transport->RemovePassenger(plMover);
-        plMover->m_transport = NULL;
-        movementInfo.ClearTransportData();
+        if (World::GetMvAnticheatDebug())
+            sLog.outDetail("Left the Transport %d", plMover->m_anti_transportGUID ? plMover->m_anti_transportGUID : 0);
+
+         plMover->m_transport->RemovePassenger(plMover);
+         plMover->m_transport = NULL;
+         plMover->m_anti_transportGUID = 0;
+         movementInfo.ClearTransportData();
+     }
+    else if (plMover && plMover->m_anti_transportGUID != 0)
+    {
+        if (World::GetMvAnticheatDebug())
+            sLog.outDetail("No more Transport %d", plMover->m_anti_transportGUID ? plMover->m_anti_transportGUID : 0);
+ 
+        plMover->m_anti_transportGUID = 0;
     }
+ 
+    if (plMover)
+     {
+        // fall damage generation (ignore in flight case that can be triggered also at lags in moment teleportation to another map).
+        if (opcode == MSG_MOVE_FALL_LAND && !plMover->isInFlight())
+        {
+            if (!plMover->m_anti_ontaxipath && !plMover->m_anti_justteleported && !plMover->m_anti_flymounted)
+                plMover->HandleFallDamage(movementInfo);
+
+            // Fix Blink / Shadowstep
+            if (plMover->m_anti_justteleported)
+                skipAnticheat = true;
+
+            // Fix KnockBack
+            if (plMover->m_anti_isknockedback)
+                forcemovement = true;
+
+            plMover->m_anti_justteleported = false;
+            plMover->m_anti_ontaxipath = false;
+            plMover->m_anti_wasflymounted = false;
+            plMover->m_anti_justjumped = 0;
+            plMover->m_anti_jumpbase = 0;
+            plMover->m_anti_isjumping = false;
+            plMover->m_anti_isknockedback = false;
+        }
+        else if (opcode == MSG_MOVE_START_SWIM)
+            plMover->m_anti_isjumping = false;
+        else if (opcode == MSG_MOVE_JUMP)
+            plMover->m_anti_isjumping = true;
+ 
+        if (plMover->m_anti_isknockedback)
+            forcemovement = true;
+ 
+        if (movementInfo.HasMovementFlag(MOVEMENTFLAG_SWIMMING) != plMover->IsInWater())
+        {
+            // now client not include swimming flag in case jumping under water
+            plMover->SetInWater(!plMover->IsInWater() || plMover->GetBaseMap()->IsUnderWater(movementInfo.GetPos()->GetPositionX(), movementInfo.GetPos()->GetPositionY(), movementInfo.GetPos()->GetPositionZ()));
+            plMover->m_anti_justjumped = 0;
+        }
+        /*----------------------*/
 
-    // fall damage generation (ignore in flight case that can be triggered also at lags in moment teleportation to another map).
-    if (opcode == MSG_MOVE_FALL_LAND && plMover && !plMover->isInFlight())
-        plMover->HandleFallDamage(movementInfo);
+        /*if (World::GetMvAnticheatDebug())
+        {
+            sLog.outBasic("%s newcoord: tm:%d ftm:%d | %f, %f, %fo(%f) [%X][%s]| transport: %f, %f, %fo(%f)", plMover->GetName(), movementInfo.time, movementInfo.GetFallTime(), movementInfo.GetPos()->GetPositionX(), movementInfo.GetPos()->GetPositionY(), movementInfo.GetPos()->GetPositionZ(), movementInfo.GetPos()->GetOrientation(), movementInfo.GetMovementFlags(), LookupOpcodeName(opcode), movementInfo.GetTransportPos()->GetPositionX(), movementInfo.GetTransportPos()->GetPositionY(), movementInfo.GetTransportPos()->GetPositionZ(), movementInfo.GetTransportPos()->GetOrientation());
+            sLog.outBasic("Transport: %d |  tguid: %d - %d", plMover->m_anti_transportGUID, GUID_LOPART(movementInfo.t_guid), GUID_HIPART(movementInfo.t_guid));
+        }*/
 
-    if (plMover && (movementInfo.HasMovementFlag(MOVEMENTFLAG_SWIMMING) != plMover->IsInWater()))
-    {
-        // now client not include swimming flag in case jumping under water
-        plMover->SetInWater(!plMover->IsInWater() || plMover->GetBaseMap()->IsUnderWater(movementInfo.GetPos()->GetPositionX(), movementInfo.GetPos()->GetPositionY(), movementInfo.GetPos()->GetPositionZ()));
-    }
+        //---- anti-cheat features -->>>
+        if (!plMover->IsInWater() && updateOrientationOnly && plMover->m_anti_transportGUID == 0)
+        {
+            if ((abs(plMover->GetPositionX() - movementInfo.GetPos()->GetPositionX()) > 0.1f) ||
+                (abs(plMover->GetPositionY() - movementInfo.GetPos()->GetPositionY()) > 0.1f) ||
+                (abs(plMover->GetPositionZ() - movementInfo.GetPos()->GetPositionZ()) > 0.1f))
+            {
+                if (World::GetMvAnticheatDebug())
+                {
+                    sLog.outError("Passiv Movement: dx=%f, dy=%f, dz=%f",
+                        abs(plMover->GetPositionX() - movementInfo.GetPos()->GetPositionX()),
+                        abs(plMover->GetPositionY() - movementInfo.GetPos()->GetPositionY()),
+                        abs(plMover->GetPositionZ() - movementInfo.GetPos()->GetPositionZ()));
+                }
+                plMover->m_anti_lastcheat = "Passiv Movement Hack";
+                check_passed = false;
+            }
+        }
 
-    uint32 mstime = getMSTime();
-    if (m_clientTimeDelay == 0)
-        m_clientTimeDelay = mstime - movementInfo.time;
+        //uint32 curDest = plMover->m_taxi.GetTaxiDestination(); // check taxi flight
+        //if ((plMover->m_anti_transportGUID == 0) && !curDest)
+        if ((plMover->m_anti_transportGUID == 0) && !plMover->m_anti_ontaxipath && !skipAnticheat)
+        {
+            UnitMoveType move_type;
+
+            if (movementInfo.HasMovementFlag(MOVEMENTFLAG_FLYING))
+                move_type = movementInfo.HasMovementFlag(MOVEMENTFLAG_BACKWARD) ? MOVE_FLIGHT_BACK : MOVE_FLIGHT;
+            else if (movementInfo.HasMovementFlag(MOVEMENTFLAG_SWIMMING))
+                move_type = movementInfo.HasMovementFlag(MOVEMENTFLAG_BACKWARD) ? MOVE_SWIM_BACK : MOVE_SWIM;
+            else if (movementInfo.HasMovementFlag(MOVEMENTFLAG_WALK_MODE))
+                move_type = MOVE_WALK;
+            else    //hmm... in first time after login player has MOVE_SWIMBACK instead MOVE_WALKBACK
+                move_type = movementInfo.HasMovementFlag(MOVEMENTFLAG_BACKWARD) ? MOVE_SWIM_BACK : MOVE_RUN;
+
+            float allowed_delta = 0;
+            float current_speed = plMover->GetSpeed(move_type);
+
+            float delta_x = plMover->GetPositionX() - movementInfo.GetPos()->GetPositionX();
+            float delta_y = plMover->GetPositionY() - movementInfo.GetPos()->GetPositionY();
+            float delta_z = plMover->GetPositionZ() - movementInfo.GetPos()->GetPositionZ();
+            float real_delta = delta_x * delta_x + delta_y * delta_y;
+
+            float time_delta = movementInfo.time - plMover->m_anti_lastmovetime;
+            if (time_delta > 0)
+                plMover->m_anti_lastmovetime = movementInfo.time;
+            else
+                time_delta = 0;
+
+            time_delta = (time_delta < 1500) ? time_delta / 1000 : 1.5f; // normalize time - 1.5 second allowed for heavy loaded server
+
+            float tg_z = -99999; // tangens
+            if (!(movementInfo.GetMovementFlags() & (MOVEMENTFLAG_FLYING | MOVEMENTFLAG_SWIMMING)))
+                tg_z = (real_delta != 0) ? (delta_z * delta_z / real_delta) : tg_z;
+
+            if (current_speed < plMover->m_anti_last_hspeed)
+            {
+                allowed_delta = plMover->m_anti_last_hspeed;
+                if (plMover->m_anti_lastspeed_changetime == 0)
+                    plMover->m_anti_lastspeed_changetime = movementInfo.time + (uint32)floor(((plMover->m_anti_last_hspeed / current_speed) * 1000)) + 100; //100ms above for random fluctuating =)))
+            }
+            else
+                allowed_delta = current_speed;
+
+            allowed_delta = allowed_delta * time_delta;
+            allowed_delta = allowed_delta * allowed_delta + 2;
+
+            // Anti-Gravitation
+            float JumpHeight = ((plMover->m_anti_jumpbase > 0) ? plMover->m_anti_jumpbase : 0) - movementInfo.GetPos()->GetPositionZ();
+            if ((plMover->m_anti_jumpbase != 0)
+                        && (plMover->m_anti_justjumped > 0)
+                        && (!plMover->m_anti_justteleported)
+                        && !(movementInfo.HasMovementFlag(MOVEMENTFLAG_SWIMMING) || movementInfo.HasMovementFlag(MOVEMENTFLAG_FLYING)
+                        || movementInfo.HasMovementFlag(MOVEMENTFLAG_FLYING2))
+                        && !(plMover-> IsInCombat() && plMover->m_anti_last_vspeed > -2)
+                        && (JumpHeight < GetPlayer()->m_anti_last_vspeed))
+            {
+                if (World::GetMvAnticheatDebug())
+                {
+                    sLog.outError("Movement Anticheat: %s is GraviJump exception. anti_jumpbase=%f, anti_justjumped=%u, JumpHeight=%f, last_vspeed=%f",
+                        plMover->GetName(), plMover->m_anti_jumpbase, plMover->m_anti_justjumped, JumpHeight, plMover->m_anti_last_vspeed);
+                }
+                plMover->m_anti_lastcheat = "GraviJump Hack";
+                check_passed = false;
+            }
 
-    /* process position-change */
-    recv_data.put<uint32>(5, movementInfo.time + m_clientTimeDelay + MOVEMENT_PACKET_TIME_DELAY);                  // offset flags(4) + unk(1)
-    WorldPacket data(opcode, mover->GetPackGUID().size() + recv_data.size());
-    data << mover->GetPackGUID();
-    data.append(recv_data.contents(), recv_data.size());
-    if (mover->isCharmed() && mover->GetCharmer())
-        mover->GetCharmer()->SendMessageToSet(&data, false);
-    else
-        mover->SendMessageToSet(&data, false);
+            // Anti-Jumphack
+            if (opcode == MSG_MOVE_JUMP && !plMover->IsInWater())
+            {
+                if (plMover->m_anti_justjumped == 0)
+                {
+                    plMover->m_anti_justjumped += 1;
+                    plMover->m_anti_jumpbase = movementInfo.GetPos()->GetPositionZ();
+                }
+                else
+                {
+                    if (World::GetMvAnticheatDebug())
+                        sLog.outError("Movement Anticheat: %s is Jumphack exception. count=%u",plMover->GetName(), plMover->m_anti_justjumped);
 
-    mover->m_movementInfo = movementInfo;
-    mover->SetPosition(movementInfo.pos);
+                    plMover->m_anti_justjumped = 0;
+                    plMover->m_anti_lastcheat = "Jump Hack";
+                    check_passed = false; //don't process new jump packet
+                }
+            }
+            else if (plMover->IsInWater())
+                plMover->m_anti_justjumped = 0;
+
+            // Anti-Speedhack
+            // Disabled to revert: if ((real_delta > allowed_delta) && (allowed_delta > 4) && (delta_z < (plMover->m_anti_last_vspeed * time_delta) || delta_z < 1) && !(plMover->isInCombat()))
+            if ((real_delta > allowed_delta)
+                 && (allowed_delta > 4)
+                 && (delta_z < 1) && !(plMover->IsInCombat()))
+            {
+                if (plMover->m_anti_speedchanged)
+                    GetPlayer()->m_anti_speedchanged = false;
+                else
+                {
+                    if (World::GetMvAnticheatDebug())
+                        sLog.outError("Movement Anticheat: %s is speed exception. real_delta=%f, allowed_delta=%f, delta_z=%f, last_vspeed=%f", plMover->GetName(), real_delta, allowed_delta, delta_z, plMover->m_anti_last_vspeed * time_delta);
 
-    if (plMover)                                            // nothing is charmed, or player charmed
-    {
-        if (opcode == MSG_MOVE_FALL_LAND || plMover->m_lastFallTime > movementInfo.GetFallTime() || plMover->m_lastFallZ < movementInfo.GetPos()->GetPositionZ())
-            plMover->SetFallInformation(movementInfo.GetFallTime(), movementInfo.GetPos()->GetPositionZ());
+                    plMover->m_anti_lastcheat = "Speed Hack";
+                    check_passed = false;
+                }
+            }
 
-        // we should add the check only for class hunter
-        if (plMover->isMovingOrTurning())
-            plMover->RemoveSpellsCausingAura(SPELL_AURA_FEIGN_DEATH);
+            // Anti-Teleport
+            // Disabled to revert: if ((real_delta > allowed_delta) && (real_delta > (time_delta * 100)))
+            if ((real_delta > 4900.0f) && !(real_delta < allowed_delta))
+            {
+                if (World::GetMvAnticheatDebug())
+                    sLog.outError("Movement Anticheat: %s is teleport exception. real_delta=%f, allowed_delta=%f, min_delta=%f ", plMover->GetName(), real_delta, allowed_delta, time_delta * 100);
 
-        if (movementInfo.GetPos()->GetPositionZ() < -500.0f)
-            plMover->HandleFallUnderMap();
-    }
+                plMover->m_anti_lastcheat = "Teleport Hack";
+                check_passed = false;
+            }
+
+            if (movementInfo.time > plMover->m_anti_lastspeed_changetime)
+            {
+                plMover->m_anti_last_hspeed = current_speed; // store current speed
+                plMover->m_anti_last_vspeed = -3.2f; // original value: -2.3f
+                plMover->m_anti_lastspeed_changetime = 0;
+            }
+ 
+            // Anti-Wallhack
+            // Known issues: jump+up, and walking up with low delta_z (one and only way to make it right is to calculate the delta_z of the terrain)
+            // Disabled to revert: if (!plMover->m_anti_isjumping && (tg_z > 1.6f) && (delta_z < (plMover->m_anti_last_vspeed * time_delta)))
+            if (!plMover->m_anti_isjumping && (tg_z > 1.56f) && (delta_z < plMover->m_anti_last_vspeed) && !(plMover->IsInCombat()))
+            {
+                if (World::GetMvAnticheatDebug())
+                    sLog.outError("Movement Anticheat: %s is a wall-climb cheater. tg_z=%f, delta_z=%f, last_vspeed=%f", plMover->GetName(), tg_z, delta_z, plMover->m_anti_last_vspeed * time_delta);
+
+                plMover->m_anti_lastcheat = "Wall-climbing Hack";
+                check_passed = false;
+            }
+
+            // Anti-Flyhack
+            if (((movementInfo.GetMovementFlags() & (MOVEMENTFLAG_CAN_FLY | MOVEMENTFLAG_FLYING | MOVEMENTFLAG_FLYING2)) != 0) && !(movementInfo.HasMovementFlag(MOVEMENTFLAG_SWIMMING)) && !(plMover->HasAuraType(SPELL_AURA_FLY) || plMover->HasAuraType(SPELL_AURA_MOD_FLIGHT_SPEED_MOUNTED)))
+            {
+                if (World::GetMvAnticheatDebug())
+                {
+                    sLog.outError("Movement Anticheat: %s is a fly cheater. {SPELL_AURA_FLY=[%X]} {SPELL_AURA_MOD_FLIGHT_SPEED_MOUNTED=[%X]} {SPELL_AURA_MOD_FLIGHT_SPEED_STACKING=[%X]} {SPELL_AURA_MOD_FLIGHT_SPEED_MOUNTED_STACKING=[%X]} {SPELL_AURA_MOD_FLIGHT_SPEED_MOUNTED_NOT_STACKING=[%X]}",
+                        plMover->GetName(),
+                        plMover->HasAuraType(SPELL_AURA_FLY), plMover->HasAuraType(SPELL_AURA_MOD_FLIGHT_SPEED_MOUNTED),
+                        plMover->HasAuraType(SPELL_AURA_MOD_FLIGHT_SPEED_STACKING), plMover->HasAuraType(SPELL_AURA_MOD_FLIGHT_SPEED_MOUNTED_STACKING),
+                        plMover->HasAuraType(SPELL_AURA_MOD_FLIGHT_SPEED_MOUNTED_NOT_STACKING));
+                }
+                plMover->m_anti_lastcheat = "Fly Hack";
+                useFallingFlag = true;
+                check_passed = false;
+            }
+
+            // Anti-Waterwalk
+            if (movementInfo.HasMovementFlag(MOVEMENTFLAG_WATERWALKING) && !(plMover->HasAuraType(SPELL_AURA_WATER_WALK) | plMover->HasAuraType(SPELL_AURA_GHOST)))
+            {
+                if (World::GetMvAnticheatDebug())
+                    sLog.outError("Movement Anticheat: %s is a water-walk cheater. MovementFlags=[%X], SPELL_AURA_WATER_WALK=[%X]", plMover->GetName(), movementInfo.GetMovementFlags(), plMover->HasAuraType(SPELL_AURA_WATER_WALK));
+
+                plMover->m_anti_lastcheat = "Water Walk Hack";
+                check_passed = false;
+            }
+
+            // Anti-Featherfall
+            if (movementInfo.HasMovementFlag(MOVEMENTFLAG_SAFE_FALL) && !(plMover->HasAuraType(SPELL_AURA_FEATHER_FALL)))
+            {
+                if (World::GetMvAnticheatDebug())
+                    sLog.outError("Movement Anticheat: %s is a featherfall-fall cheater. MovementFlags=[%X], SPELL_AURA_FEATHER_FALL=[%X]", plMover->GetName(), movementInfo.GetMovementFlags(), plMover->HasAuraType(SPELL_AURA_FEATHER_FALL));
+
+                plMover->m_anti_lastcheat = "Feather Fall Hack";
+                check_passed = false;
+            }
+
+            // Anti-TeleportToPlane
+            if (movementInfo.GetPos()->GetPositionZ() < 0.0001f && movementInfo.GetPos()->GetPositionZ() > -0.0001f && ((movementInfo.GetMovementFlags() & (MOVEMENTFLAG_SWIMMING | MOVEMENTFLAG_CAN_FLY | MOVEMENTFLAG_FLYING | MOVEMENTFLAG_FLYING2)) == 0))
+            {
+                // Prevent using TeleportToPlane.
+                Map *map = plMover->GetMap();
+                if (map)
+                {
+                    float plane_z = map->GetHeight(movementInfo.GetPos()->GetPositionX(), movementInfo.GetPos()->GetPositionY(), MAX_HEIGHT) - movementInfo.GetPos()->GetPositionZ();
+                    plane_z = (plane_z < -500.0f) ? 0 : plane_z; // check holes in height map
+                    if (plane_z > 0.1f || plane_z < -0.1f)
+                    {
+                        if (World::GetMvAnticheatDebug())
+                            sLog.outError("Movement Anticheat: %s uses teleport to plane. plane_z: %f ", plMover->GetName(), plane_z);
+
+                        plMover->m_anti_lastcheat = "Teleport to Plane Hack";
+                        check_passed = false;
+                    }
+                }
+            }
+        }
+        else if (movementInfo.HasMovementFlag(MOVEMENTFLAG_ONTRANSPORT))
+        {
+            // Anti-Wrap
+            if (plMover->m_transport)
+            {
+                float trans_rad = movementInfo.GetTransportPos()->GetPositionX() * movementInfo.GetTransportPos()->GetPositionX() + movementInfo.GetTransportPos()->GetPositionY() * movementInfo.GetTransportPos()->GetPositionY() + movementInfo.GetTransportPos()->GetPositionZ() * movementInfo.GetTransportPos()->GetPositionZ();
+                if (trans_rad > 3600.0f)
+                    check_passed = false;
+            }
+            else
+            {
+                if (GameObjectData const* go_data = sObjectMgr.GetGOData(plMover->m_anti_transportGUID))
+                {
+                    if (World::GetMvAnticheatDebug())
+                        sLog.outError("Movement Anticheat: %s on some transport. xyz: %f, %f, %f", plMover->GetName(), go_data->posX, go_data->posY, go_data->posZ);
+
+                    int mapid = go_data->mapid;
+                    if (plMover->GetMapId() != mapid)
+                    {
+                        check_passed = false;
+                    }
+                    else if (mapid != 369)
+                    {
+                        float delta_gox = go_data->posX - movementInfo.GetPos()->GetPositionX();
+                        float delta_goy = go_data->posY - movementInfo.GetPos()->GetPositionY();
+                        float delta_go = delta_gox*delta_gox + delta_goy*delta_goy;
+                        if (delta_go > 3600.0f)
+                            check_passed = false;
+                    }
+                }
+                else
+                {
+                    if (World::GetMvAnticheatDebug())
+                        sLog.outError("Movement Anticheat: %s on undefined transport.", plMover->GetName());
+
+                    check_passed = false;
+                }
+            }
+
+            if (!check_passed)
+            {
+                plMover->m_anti_lastcheat = "Transport";
+                if (plMover->m_transport)
+                {
+                    plMover->m_transport->RemovePassenger(plMover);
+                    plMover->m_transport = NULL;
+                }
+                movementInfo.ClearTransportData();
+                plMover->m_anti_transportGUID = 0;
+            }
+        }
+
+        if (check_passed ||
+            forcemovement ||
+            !World::GetEnableMvAnticheat() ||
+            GetPlayer()->GetSession()->GetSecurity() > World::GetMvAnticheatGmLevel())
+        {
+            /* process position-change */
+            recv_data.put<uint32>(5, getMSTime());                  // offset flags(4) + unk(1)
+            WorldPacket data(opcode, mover->GetPackGUID().size() + recv_data.size());
+            data << mover->GetPackGUID();
+            data.append(recv_data.contents(), recv_data.size());
+            mover->SendMessageToSet(&data, false);
+            if (updateOrientationOnly)
+                plMover->SetPosition(plMover->GetPositionX(), plMover->GetPositionY(), plMover->GetPositionZ(), movementInfo.GetPos()->GetOrientation());
+            else
+                plMover->SetPosition(movementInfo.GetPos()->GetPositionX(), movementInfo.GetPos()->GetPositionY(), movementInfo.GetPos()->GetPositionZ(), movementInfo.GetPos()->GetOrientation());
+
+            plMover->m_movementInfo = movementInfo;
+
+            if (opcode == MSG_MOVE_FALL_LAND || plMover->m_lastFallTime > movementInfo.GetFallTime() || plMover->m_lastFallZ < movementInfo.GetPos()->GetPositionZ())
+                plMover->SetFallInformation(movementInfo.GetFallTime(), movementInfo.GetPos()->GetPositionZ());
+            // we should add the check only for class hunter
+            if (plMover->isMovingOrTurning())
+                plMover->RemoveSpellsCausingAura(SPELL_AURA_FEIGN_DEATH);
+
+            if (movementInfo.GetPos()->GetPositionZ() < -500.0f)
+                plMover->HandleFallUnderMap();
+        }
+        else
+        {
+            WorldPacket data;
+            // Temporary disabled maybee cause fall dmg on dismount in air
+            /* if (useFallingFlag)
+                plMover->SetUnitMovementFlags(MOVEFLAG_FALLING);
+            else
+                plMover->SetUnitMovementFlags(MOVEFLAG_NONE);
+            */
+            plMover->SetUnitMovementFlags(MOVEMENTFLAG_NONE);
+            plMover->BuildTeleportAckMsg(&data, plMover->GetPositionX(), plMover->GetPositionY(), plMover->GetPositionZ(), plMover->GetOrientation());
+            plMover->GetSession()->SendPacket(&data);
+            plMover->BuildHeartBeatMsg(&data);
+            plMover->SendMessageToSet(&data, true);
+
+            switch (World::GetMvAnticheatAction())
+            {
+            case 0:
+                sWorld.SendGMText(LANG_GM_AC_ANNOUNCE, plMover->GetName(), plMover->m_anti_lastcheat.c_str());
+                break;
+            case 1:
+                plMover->GetSession()->KickPlayer();
+                sWorld.SendGMText(LANG_GM_AC_KICK_ANNOUNCE, plMover->GetName(), plMover->m_anti_lastcheat.c_str());
+                break;
+            case 2:
+                std::string accountName;
+                sAccountMgr->GetName(plMover->GetSession()->GetAccountId(), accountName);
+                std::stringstream duration;
+                duration << World::GetMvAnticheatBanDuration() << "s";
+                sWorld.BanAccount(BAN_ACCOUNT, accountName, duration.str(), plMover->m_anti_lastcheat.c_str(),"AC");
+                sWorld.SendGMText(LANG_GM_AC_BAN_ANNOUNCE, plMover->GetName(), plMover->m_anti_lastcheat.c_str());
+                break;
+            }
+        }
+     }
+    else
+    if (getMSTimeDiff(timediff, getMSTime()) > 20)
+        sLog.outError("Anticheat Process Time: %ums : %s [%x]", getMSTimeDiff(timediff, getMSTime()), LookupOpcodeName(opcode), movementInfo.GetMovementFlags());
 }
 
 void WorldSession::HandleForceSpeedChangeAck(WorldPacket& recv_data)
 {
+    GetPlayer()->m_anti_speedchanged = true;
     DEBUG_LOG("WORLD: Recvd CMSG_SPEED_CHANGE_ACK");
     /* extract packet */
     ObjectGuid guid;
